# OCJP Silver SE11 第5章 配列の操作

OCJP Silver 第5章、配列の操作について考えていきます。

## 配列

これまでプログラム例の中で適当に配列を使ってきましたが、ここで一度配列についてまとめておきたいと思います。

配列は長さが固定された値の列で、Javaでは値が一列に並んだ1次元配列が基本になっています。

感覚的には特定の型の値を保持する箱が一列に並んだものと考えてもいいと思います。

### 配列変数の宣言

配列変数の宣言は以下のように型名の後に「[]」を書くことで行います。

```java
int[] a;
```

上の例では整数型 (**int**) の配列変数*a*を宣言しています。

Javaでは配列変数を宣言しただけでは変数は初期化されないので、配列オブジェクトを生成する必要があります。

また、C言語などのように```int[3] a;```といった形で配列のサイズを変数宣言時に行うこともできません。

### 配列オブジェクトの生成

配列オブジェクトは**new**を使用して以下のように生成します。

```java
int[] a;
a = new int[3];
```

もちろん、以下のように配列変数宣言時に変数の初期化として書くことも可能です。

```java
int[] a = new int[3];
```

このように初期化を行うと配列の各要素は既定の値、上の例のように整数型であれば0に初期化されます。

他の値で初期化を行いたい場合は以下のように中かっこ「{}」でくくり、カンマ「,」で区切った値の列で初期化を行います。

```java
int[] a = {1, 2, 3};
```

当然ですが、初期化する値は配列の要素型と互換性のある値でなければなりません。

また、以下のように**new**と組み合わせて初期化することもできます。

```java
int[] a = new int[]{1, 2, 3};
```

プリミティブ型ではこの書き方をする必要はほぼありませんが、そのうち出てくるオブジェクトの継承やインタフェースの実装と関連してこういった書き方が必要となる場合があります。

### オブジェクトとしての配列

配列は単に値を入れる容器の列ではなく、オブジェクトとして定義されており、いくつかの特別なふるまいが提供されています。

まず、配列はサイズ (要素数) を変更することができません。

配列のサイズを取得するには**length**というインスタンス変数を使用して、```size = a.length```という形で読み取ります。

配列のコピーを取得するには**clone**というインスタンスメソッドを使用し、```int[] a2 = a.clone();```のように実行します。

```int[] a2 = a```のように変数の代入を行った場合には*a*と*a2*は同じ配列オブジェクトを参照するため、配列*a*に対する変更が配列*a2*にも反映されたように見えてしまいます。

同じ値で初期化された別の配列を生成する際には必ず**clone**メソッドを使用してください。

配列はオブジェクトですので**toString**メソッドや**equals**メソッドを使用できますが、必ずしも期待する結果になるとは限りません。

### 配列要素へのアクセス

配列要素からの値の読み出しは```int i = a[2];```のように角カッコ「[]」で要素位置を指定します。

要素位置は0はじまりですので、配列のサイズ以上の要素位置、あるいはマイナスの要素位置を指定した場合には例外 (**ArrayIndexOutOfBoundsException**) が発生します。

配列要素への値の書き込みも同様に```a[1] = 3;```のように角カッコ「[]」で要素位置を指定します。

こちらも同様に不正な要素位置指定がされると例外が発生します。

## 多次元配列

Javaの配列は基本的には要素が1列に並んだ1次元配列だけで、縦横に要素が並ぶ2次元配列などの多次元配列は配列の配列として実現されます。

```java
int[][] a;
```

上のような配列変数の宣言を行った場合、*a*は**int**型の配列の配列となります。

例えば3×3の配列での初期化をステップごとに行うと以下のようになります。

```java
int[][] a;

a = new int[3][];
a[0] = new int[3];
a[1] = new int[3];
a[2] = new int[3];
```

最初の配列生成```a = new int[3][];```は原理主義的にはちょっと気持ち悪くて、int[]型の配列を生成するのだから```a = new int[][3];```の方が論理的にはすんなり受け入れられます。

が、こうすると配列へのアクセス時の要素指定と指定の順序が変わってしまうという問題があるので、気持ち悪いけれども現在の形になっているのではないかと私は考えています。

それはそれとして、これでは面倒なので以下のような簡略記法が提供されています。

```java
int[][] a = new int[3][3];
```

また、値で初期化する際にも簡略記法があります。

```java
int[][] a = {{1,2,3}, {4,5,6}, {7,8,9}};
```

しかし、簡略記法を使っても多次元配列になるわけではなくあくまで配列の配列であることに注意してください。

## 拡張for文

配列要素を順番に処理する場合、普通は**for**文が使われます。

```java
String a[] = {"A", "B", "C"};

for (int i = 0; i < a.length; ++i) {
    System.out.println(a[i] + " ");
}
```

この例をよく見ると、ループ変数*i*は配列の要素にアクセスするためにしか使用されていません。

もしも配列要素を直接取り出せたらもうちょっと便利になるのではということで導入されたのが拡張**for**文です。

```java
String[] a = {"A" + "B" + "C"};

for (String s: a) {
    System.out.println(s + " ");
}
```

**for**のカッコ「()」の中にコロン「:」で区切って左側に要素を受け取る変数、右側に配列など読み取られるオブジェクトを書くと、オブジェクト内の要素が順次変数に代入されてループ本体が実行されます。

多少の制約がありますがループ変数を使用するより簡潔に書ける場合が多いので、配列などの要素を順番に処理する場合にはこちらも検討してください。

拡張for文は別の機会でも触れていくことがあると思います。

今回は簡単に配列と拡張for文について考えてみました。
