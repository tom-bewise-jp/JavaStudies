# OCJP Silver SE11 第7章 クラスの継承、インタフェース、抽象クラス

さて、Javaを学ぶ上で一番面白い継承やらポリモフィズムやらというところに入ってきました。

普通この辺はクラスの継承から話が始まっていくのですが、ここでは少し趣向を変えてインタフェースから話を進めていきたいと思います。

## インタフェース

インタフェースは以下のような形式で書きます。

```java
public interface AInterface {
    void doSomething(int param);
}
```

先頭の```public interface AInterface```で**AInterface**という名前のインタフェースを宣言しています。

中かっこ「{}」で囲まれた中がインタフェースの本体で、ここではメソッドを1個だけ宣言しています。

2行目の```void doSomething(int param);```がメソッドの宣言で、**int**型の引数**param**を1個とり戻り値を持たない**doSomething**メソッドを宣言しています。

インタフェースで宣言するメソッドは基本的にはそのメソッドをどのように実行するかを示す本体を持たないので宣言の終わりはセミコロン「;」になっています。

インタフェースにおけるメソッド宣言はインタフェースを実装するオブジェクトで使用できるメソッドを知らせるものとなります。

インタフェース**AInterface**を実装するオブジェクトは必ず**doSomething**メソッドが使えなければならず、その動作は**AInteface**インタフェースで定められた仕様を満たしていることが期待されます。

つまりインタフェースを実装するということはインタフェースが決めている約束あるいは契約を守っているということを宣言するということになります。

それではインタフェースを実装したクラスを見てみます。

```java
public class AClass implements AInterface {
    // いろいろあるけどとりあえず省略

    @Override
    public void doSomething(int param) {
        // doSomethingメソッドの本体
    }

    // ほかにもあるけどとりあえず省略
}
```

上の例にあるようにインタフェースを実装するクラスは```public class AClass implements AInterface``とクラス宣言に**inplements**キーワードと実装するインタフェース名を記述します。

こう書くことで**AClass**クラスのオブジェクトは**AInterface**が規定する契約を守っていることを宣言し、**AInterface**型のオブジェクトとしても使用できるということを示しています。

そして**AInterface**インタフェースで定義されたメソッド**doSomething**を上の例に示したように**public**を指定する必要があります。

これはインタフェースで定義されたメソッドはどのクラスからも使えることが契約となっているからです。

### インタフェースの例: java.util.List

インタフェースはどのように使われるか、その実例として標準ライブラリに含まれる[java.util.List](https://docs.oracle.com/en/java/javase/19/docs/api/java.base/java/util/List.html)インタフェースを見ておこうと思います。

Listインタフェースを実装したオブジェクトは以下のような機能を持つことが期待されます。

- [**add**](https://docs.oracle.com/en/java/javase/19/docs/api/java.base/java/util/List.html#add(E))メソッドを使用してリストの最後にオブジェクトを追加することができる。

- [インデクス付きの**add**](https://docs.oracle.com/en/java/javase/19/docs/api/java.base/java/util/List.html#add(int,E))メソッドを使用してリストのインデクスでしてされた位置にオブジェクトを挿入することができる。

- [**get**](https://docs.oracle.com/en/java/javase/19/docs/api/java.base/java/util/List.html#get(int))メソッドを指定してインデクスで指定した位置のオブジェクトを読み出すことができる。

- [**set**](https://docs.oracle.com/en/java/javase/19/docs/api/java.base/java/util/List.html#set(int,E))メソッドを使用してインデクスで指定した位置のオブジェクトを変更することができる。

- [**remove**](https://docs.oracle.com/en/java/javase/19/docs/api/java.base/java/util/List.html#remove(int))メソッドを使用してインデクスで指定した位置のオブジェクトを削除することができる。

ほかにも多くのメソッドが定義されていますが、詳しくはリンク先のドキュメントを参照してください。

**List**インタフェースを実装したクラスの例として、標準ライブラリには[**java.util.ArrayList**](https://docs.oracle.com/en/java/javase/19/docs/api/java.base/java/util/ArrayList.html)クラス、[**java.util.LinkedList**](https://docs.oracle.com/en/java/javase/19/docs/api/java.base/java/util/LinkedList.html)クラスなどがあります。

詳細はリンク先を見ていただくとわかりますが、**ArrayList**クラスのオブジェクトはインデクスで指定された位置のオブジェクトを効率的に取得できるのに対して、**LinkedList**クラスのオブジェクトはリストの途中にオブジェクトを挿入・削除する操作を効率的に実行することができます。

これら2種類のクラスにはそれぞれ得意不得意があるので、プログラム開発の途中で性能が足りないことが判明して差し替えるといったことも行われますが、利用側が特定のクラスではなく**List**インタフェースのオブジェクトとして運用していれば、どちらのクラスのオブジェクトを使っているかに関係なく処理を行うことができます。

このように契約部分と実際の処理を分離して、オブジェクトの利用側は契約に基づいてオブジェクトが動作することを期待してプログラムを作成し、契約に基づいてはいるが異なる特性を持ったオブジェクトを必要に応じて使い分けること、あるいは契約の基づいてはいるが異なる特性を持ったオブジェクトを用意することを「ポリモフィズム」と呼んでいます。

### 定数定義

インタフェースは定数を定義することができます。

定数定義の例を以下に示します。

```java
public interface SomeInterface {
    int A_CONSTANT = 42;
}
```

インタフェースでは定数は宣言と同時に初期化されなければなりません。

また、定数は**static**の指定がなくともクラス定数 (スタティックフィールド) 扱いとなります。

### デフォルトメソッド

インタフェースのメソッド定義は本体を持たないので、メソッド本体はインタフェースを実装するクラスでクラスごとに実装しなければなりません。

これは少し面倒なので、デフォルトメソッドという仕組みが用意されています。

デフォルトメソッドは以下のように記述します。

```java
public interface SomeInteface {
    default int doSomething(double param) {
        // メソッドの本体
    }
}
```

インタフェースはクラス変数やメンバ変数を持つことができないので、デフォルト実装でできることはざっくりいうと脊髄反射で返せるレベルの操作のみとなります。

### インタフェースの拡張

以下のように**extends** キーワードを使用することでインタフェースを拡張することができます。

```java
public interface AnotherInterface extends SomeInterface {
    // インタフェース定義
}
```

インタフェースを拡張することで定数の追加、メソッド定義の追加、メソッド定義へのデフォルトメソッドの追加、変更が可能となります。

拡張されたインタフェースで定数が再定義された場合、同じ名前の定数が拡張前のインタフェースと拡張したインタフェースの両方で定義されている場合には以下のようになります。

- 拡張前のインタフェースを指定して定数を参照した場合 → 拡張前のインタフェースの定数が参照されます

- 拡張後のインタフェースを指定して定数を参照した場合 → 拡張後のインタフェースの定数定義が参照されます

- 拡張後のインタフェースを実装したクラスを指定して定数を参照した場合 → 拡張後のインタフェースで定義された定数が参照されます

インタフェースで定義された定数は定義したインタフェースに紐づけられているので、どの名前で呼ぶかに依存した結果となります。

拡張されたインタフェースでメソッドが再定義された場合、同じ名前のメソッドが拡張前のインタフェースと拡張した後のインタフェースの両方で定義されている場合には以下のようになります。

- 拡張前のインタフェースで定義されたメソッドと拡張したインタフェースで定義されたメソッドの引数の数、型、並びが一致していない場合 → 別のメソッドとして認識されますので、それぞれに対して実装が必要となります。

- 拡張前のインタフェースで定義されたメソッドと拡張したインタフェースで定義されたメソッドの引数の数、型、並びが一致していて、かつ両方ともメソッド本体を持たない場合 → 戻り値の型が一致していない場合はエラーとなり、戻り値の形が一致している場合は特に何も起きません。

- 拡張前のインタフェースで定義されたメソッドと拡張したインタフェースで定義されたメソッドの引数の数、型、並びが一致していて、拡張したインタフェースで定義したメソッドがデフォルトメソッドを持っている場合 → 拡張したインタフェースで定義されたデフォルトメソッドがインタフェースを実装したクラスで使用されます。

- 拡張前のインタフェースで定義されたメソッドと拡張したインタフェースで定義されたメソッドの引数の数、型、並びが一致していて、拡張前のインタフェースで定義したメソッドはデフォルトメソッドを持っているが拡張したインタフェースはデフォルトメソッドを持っていない場合 → 拡張前のインタフェースで定義されたデフォルトメソッドは無効となり、インタフェースを実装したクラスではデフォルトメソッドを使用できません。

もちろんインタフェースを実装したクラスがメソッドの動作としてデフォルトメソッドとは異なる処理を行いたい場合には、クラスでメソッドを実装することでインタフェースで実装されたデフォルトメソッドを上書きすることができます。

## クラスの継承

インタフェースはデフォルトメソッドによりメソッド本体を定義することができますが、メンバ変数を持つことができないため、デフォルトメソッドでできることは限定されてしまいます。

このため、例えばそれまでの操作の履歴に応じて動作が変わるような状態を持った契約が必要な場合にはインタフェースを実装するのではなく、クラスを継承するという方法を使用します。

例えばあるクラス (AClass) が以下のように定義されているとします。

```java
public class AClass {
    public int doOneThing(int param) {
        // 何らかの処理
    }

    public int doSomething(int param) {
        // 何らかの処理
    }
}
```

このクラスを拡張して新しい機能を追加、変更したクラス (AnotherClass) を定義するには以下のように書きます。

```java
public class AnotherClass extends AClass {
    @Override
    public int doSomething(int param) {
        // AClassとは別の処理
    }

    public int doAnotherThing(int param) {
        // 何らかの処理
    }
}
```

拡張したクラス (AnotherClass) のオブジェクトは以下のような特性を持ちます。

まず、拡張したクラスで定義されたメソッド (doAnotherthing) は拡張したクラスのオブジェクトでのみ使用することができ、拡張元のクラス (AClass) のオブジェクトでは使用することができません。

拡張元だけで定義されているメソッド (doOneThing) は拡張元のクラス (AClass) と拡張したクラス (AnotherClass) のどちらのオブジェクトでも同じものを使用することができます。

そしてdoSomethingのように拡張元のクラスと拡張したクラスで異なる実装を持ったメソッドは、拡張元のクラス (AClass) のオブジェクトでは常に拡張元のクラスのメソッドが実行され、拡張したクラス (AnotherClass) のオブジェクトでは常に拡張したクラスのメソッドが使用されます。

このようにクラスを拡張して機能の追加・変更を行うことをクラスの継承と呼んでいます。

